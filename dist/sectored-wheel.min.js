(()=>{const t=function*(t){let e=0;for(;;)e>=t.length&&(e=0),yield t[e],e++};class e extends HTMLElement{shadow=null;onConnect(){}onDisconnect(){}constructor(){super()}emit(t,e){const s=new CustomEvent(t,{detail:{element:this,data:e}}),r=this[`on${t}`];if("function"==typeof r)r.call(this,s);else{const e=this.getAttribute(`on${t}`);e?new Function("e",`var event = e; return ${e}`):this.dispatchEvent(s)}}connectedCallback(){this.shadow=this.attachShadow({mode:"open"}),this.onConnect()}disconnectedCallback(){this.onDisconnect()}}class s extends e{#t;onConnect(){super.onConnect();const t=document.createElement("template");t.innerHTML='<style>\n            :host {\n                display: flex;\n                flex-direction: row;\n                justify-content: flex-end;\n                align-items: center;\n                padding-right: calc(var(--radius) * 0.15);\n                box-sizing: border-box;\n                position: absolute;\n                color: #000;\n                left: 50%;\n                width: var(--radius);\n                height: var(--sector-height);\n                font-size: min(calc(var(--sector-height) * 0.2), calc(var(--radius) / 8));\n                font-weight: bold;\n                font-family: sans-serif;\n                text-transform: uppercase;\n                transform-origin: 0 50%;\n                z-index: 1;\n            }\n            :host::before {\n                --width: calc(var(--radius) / 15);\n                --border: calc(var(--width) / 4);\n                content: "";\n                width: var(--width);\n                aspect-ratio: 1/1;\n                position: absolute;\n                right: 0;\n                transform-origin: calc((var(--radius) - var(--width)) * -1) 50%;\n                transform: rotate(calc(var(--sector-angle) / 2)) translateX(calc(var(--border) * -1));\n                border-radius: 50%;\n                box-shadow:\n                    inset rgba(0,0,0,0.1) 0 0 0 var(--border),\n                    inset var(--rim-color) 0 0 0 var(--width),\n                    rgba(0,0,0,0.1) calc(var(--border) * -1) 0 0 0;\n            }\n        </style><slot class="sector"></slot>',this.shadow.appendChild(t.content),this.#t=this.shadow.querySelector("slot.sector")}}window.customElements.get("sectored-wheel-item")||(window.SectorElement=s,window.customElements.define("sectored-wheel-item",s));class r extends e{#e;#t;#s=0;#r=0;#n=0;#o=!0;#i=[];#a=t([]);#c;#l;cssVarsForcing=t=>{this.#l&&-1===t.indexOf("--radius")&&(this.size=this.#l),this.#c&&-1===t.indexOf("--rim-color")&&(this.rimColor=this.#c),this.#i&&this.#i.length&&-1===t.indexOf("--color1")&&this.setColors(this.#i,!0),this.#n&&-1===t.indexOf("--sectors-count")&&this.style.setProperty("--sectors-count",this.#n)};realign=()=>{const t=[],e=this.querySelectorAll("sectored-wheel-item");this.#n=e.length,this.style.setProperty("--sectors-count",this.#n);for(let e=0;e<this.#n;e++)t.push(`var(${this.#a.next().value}) calc(var(--sector-angle) * ${e}) calc(var(--sector-angle) * ${e+1})`);this.#t.style.background=`conic-gradient(from calc(90deg - var(--sector-angle) / 2), ${t.join(", ")})`,e.forEach(((t,e)=>{t.style.transform=`rotate(calc(var(--sector-angle) * ${e}))`}))};static get observedAttributes(){return["colors","rim-color","size","index","style"]}attributeChangedCallback(t,e,s){if(e!==s)switch(t){case"colors":this.setColors(s);break;case"rim-color":this.rimColor=s;break;case"size":this.size=s;case"style":this.cssVarsForcing(s)}"index"===t&&(this.index=s)}rotate(t,e){if(this.#n){const s=360/this.#n;this.#s-=360+s*(t<e?Math.abs(e-t):Math.abs(this.#n-t+e)),this.#t.style.transform=`rotate(${this.#s-90}deg)`}}set index(t){const e=parseInt(t||0,10);this.#n&&(this.#o=!1,this.rotate(this.#r,e)),this.#r=e}get index(){return this.#r}set size(t){this.#l=t||"100px",this.style.setProperty("--radius",`calc(${t} / 2)`)}get size(){return this.#l}set rimColor(t){this.#c=t||"silver",this.style.setProperty("--rim-color",t)}get rimColor(){return this.#c}setColors(e,s){!s&&this.#i.length&&this.#i.forEach(((t,e)=>{this.style.removeProperty(`--color${e}`)})),Array.isArray(e)?this.#i=e:this.#i=String(e).split(/\s*[;|]+\s*/).filter(Boolean);const r=this.#i.map(((t,e)=>{const s=`--color${e}`;return this.style.setProperty(s,t),s}));this.#a=t(r)}onConnect(){super.onConnect();const t=document.createElement("template");t.innerHTML='<style>\n            :host {\n                position: relative;\n                display: inline-flex;\n                justify-content: center;\n                align-items: center;\n                flex-grow: 0;\n                flex-shrink: 0;\n                user-select: none;\n                min-width: 100px;\n                border-radius: 50%;\n                background: rgba(255, 255, 255, 0.2);\n                width: calc(var(--radius) * 2);\n                --radius: 50px;\n                --sector-height: calc((6.28 * var(--radius)) / var(--sectors-count));\n                --sector-angle: calc(360deg / var(--sectors-count));\n                box-shadow:\n                    rgba(0,0,0,0.1) 0 0 0 calc(var(--radius) / 25);;\n            }\n            :host::after {\n                --width: calc(var(--radius) / 6);\n                --border: calc(var(--width) / 10);\n                content: "";\n                position: absolute;\n                aspect-ratio: 1/1;\n                border-radius: 50%;\n                background-color: white;\n                width: var(--width);\n                box-shadow:\n                    inset rgba(0,0,0,0.1) 0 0 0 var(--border), \n                    inset var(--rim-color) 0 0 0 calc(var(--border) * 2.5),\n                    rgba(0,0,0,0.1) 0 0 0 calc(var(--border) * 2);\n            }\n            :host::before {\n                --width: calc(var(--radius) / 6);\n                --border: calc(var(--width) / 10);\n                content: "";\n                position: absolute;\n                top: 0;\n                aspect-ratio: 1/1;\n                border-radius: 50% 50% 50% 20%;\n                transform: translateY(-60%) rotate(-45deg);\n                background-color: white;\n                width: var(--width);\n                z-index: 1;\n                box-shadow:\n                    inset rgba(0,0,0,0.1) 0 0 0 var(--border), \n                    inset var(--rim-color) 0 0 0 calc(var(--border) * 3),\n                    rgba(0,0,0,0.1) 0 0 0 calc(var(--border) * 2);\n            }\n            :host > slot.wheel {\n                position: relative;\n                display: flex;\n                justify-content: center;\n                align-items: center;\n                width: 100%;\n                aspect-ratio: 1/1;\n                border-radius: 50%;\n                overflow: hidden;\n                transform: rotate(-90deg);\n                transition: transform 5s cubic-bezier(0.25, 1, 0.5, 1);\n                box-shadow:\n                    inset rgba(0,0,0,0.3) 0 0 0 calc(var(--radius) * 0.01),\n                    inset var(--rim-color) 0 0 0 calc(var(--radius) * 0.05),\n                    inset rgba(0,0,0,0.1) 0 0 0 calc(var(--radius) * 0.07);\n            }\n        </style><slot class="wheel"></slot>',this.shadow.appendChild(t.content),this.#t=this.shadow.querySelector("slot.wheel"),this.#e=new MutationObserver(this.realign),this.#e.observe(this,{childList:!0}),this.#t.addEventListener("transitionend",(()=>{this.#o||this.emit("change",this.#r),this.#o=!1})),this.realign(),requestAnimationFrame((()=>{this.rotate(0,this.index)}))}onDisconnect(){this.#e.disconnect(),super.onDisconnect()}}window.customElements.get("sectored-wheel")||(window.SectoredWheelElement=r,window.customElements.define("sectored-wheel",r))})();